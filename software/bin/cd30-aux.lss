
cd30-aux.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00000904  00000998  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000904  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000003f  0080011e  0080011e  000009b6  2**0
                  ALLOC
  3 .stab         000022ec  00000000  00000000  000009b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001600  00000000  00000000  00002ca4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000042a4  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000042b8  2**2
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__ctors_end>
   4:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
   8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
   c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  10:	0c 94 43 02 	jmp	0x486	; 0x486 <__vector_4>
  14:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  18:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  1c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  20:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  24:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  28:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  2c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  30:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  34:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  38:	0c 94 1e 02 	jmp	0x43c	; 0x43c <__vector_14>
  3c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  40:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  44:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  48:	0c 94 3b 04 	jmp	0x876	; 0x876 <__vector_18>
  4c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  50:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  54:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  58:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  5c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  60:	0c 94 81 01 	jmp	0x302	; 0x302 <__vector_24>
  64:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  68:	c3 01       	movw	r24, r6
  6a:	99 01       	movw	r18, r18
  6c:	99 01       	movw	r18, r18
  6e:	99 01       	movw	r18, r18
  70:	99 01       	movw	r18, r18
  72:	99 01       	movw	r18, r18
  74:	99 01       	movw	r18, r18
  76:	99 01       	movw	r18, r18
  78:	c3 01       	movw	r24, r6
  7a:	99 01       	movw	r18, r18
  7c:	99 01       	movw	r18, r18
  7e:	99 01       	movw	r18, r18
  80:	99 01       	movw	r18, r18
  82:	99 01       	movw	r18, r18
  84:	99 01       	movw	r18, r18
  86:	99 01       	movw	r18, r18
  88:	db 01       	movw	r26, r22
  8a:	99 01       	movw	r18, r18
  8c:	99 01       	movw	r18, r18
  8e:	99 01       	movw	r18, r18
  90:	99 01       	movw	r18, r18
  92:	99 01       	movw	r18, r18
  94:	99 01       	movw	r18, r18
  96:	99 01       	movw	r18, r18
  98:	99 01       	movw	r18, r18
  9a:	99 01       	movw	r18, r18
  9c:	99 01       	movw	r18, r18
  9e:	99 01       	movw	r18, r18
  a0:	99 01       	movw	r18, r18
  a2:	99 01       	movw	r18, r18
  a4:	99 01       	movw	r18, r18
  a6:	99 01       	movw	r18, r18
  a8:	db 01       	movw	r26, r22
  aa:	99 01       	movw	r18, r18
  ac:	99 01       	movw	r18, r18
  ae:	99 01       	movw	r18, r18
  b0:	99 01       	movw	r18, r18
  b2:	99 01       	movw	r18, r18
  b4:	99 01       	movw	r18, r18
  b6:	99 01       	movw	r18, r18
  b8:	99 01       	movw	r18, r18
  ba:	99 01       	movw	r18, r18
  bc:	99 01       	movw	r18, r18
  be:	99 01       	movw	r18, r18
  c0:	99 01       	movw	r18, r18
  c2:	99 01       	movw	r18, r18
  c4:	99 01       	movw	r18, r18
  c6:	99 01       	movw	r18, r18
  c8:	de 01       	movw	r26, r28
  ca:	99 01       	movw	r18, r18
  cc:	99 01       	movw	r18, r18
  ce:	99 01       	movw	r18, r18
  d0:	99 01       	movw	r18, r18
  d2:	99 01       	movw	r18, r18
  d4:	99 01       	movw	r18, r18
  d6:	99 01       	movw	r18, r18
  d8:	e2 01       	movw	r28, r4
  da:	99 01       	movw	r18, r18
  dc:	99 01       	movw	r18, r18
  de:	99 01       	movw	r18, r18
  e0:	99 01       	movw	r18, r18
  e2:	99 01       	movw	r18, r18
  e4:	99 01       	movw	r18, r18
  e6:	99 01       	movw	r18, r18
  e8:	99 01       	movw	r18, r18
  ea:	99 01       	movw	r18, r18
  ec:	99 01       	movw	r18, r18
  ee:	99 01       	movw	r18, r18
  f0:	99 01       	movw	r18, r18
  f2:	99 01       	movw	r18, r18
  f4:	99 01       	movw	r18, r18
  f6:	99 01       	movw	r18, r18
  f8:	f0 01       	movw	r30, r0
  fa:	99 01       	movw	r18, r18
  fc:	99 01       	movw	r18, r18
  fe:	99 01       	movw	r18, r18
 100:	99 01       	movw	r18, r18
 102:	99 01       	movw	r18, r18
 104:	99 01       	movw	r18, r18
 106:	99 01       	movw	r18, r18
 108:	b1 01       	movw	r22, r2

0000010a <__ctors_end>:
 10a:	11 24       	eor	r1, r1
 10c:	1f be       	out	0x3f, r1	; 63
 10e:	cf ef       	ldi	r28, 0xFF	; 255
 110:	d8 e0       	ldi	r29, 0x08	; 8
 112:	de bf       	out	0x3e, r29	; 62
 114:	cd bf       	out	0x3d, r28	; 61

00000116 <__do_copy_data>:
 116:	11 e0       	ldi	r17, 0x01	; 1
 118:	a0 e0       	ldi	r26, 0x00	; 0
 11a:	b1 e0       	ldi	r27, 0x01	; 1
 11c:	e4 e0       	ldi	r30, 0x04	; 4
 11e:	f9 e0       	ldi	r31, 0x09	; 9
 120:	02 c0       	rjmp	.+4      	; 0x126 <__do_copy_data+0x10>
 122:	05 90       	lpm	r0, Z+
 124:	0d 92       	st	X+, r0
 126:	ae 31       	cpi	r26, 0x1E	; 30
 128:	b1 07       	cpc	r27, r17
 12a:	d9 f7       	brne	.-10     	; 0x122 <__do_copy_data+0xc>

0000012c <__do_clear_bss>:
 12c:	21 e0       	ldi	r18, 0x01	; 1
 12e:	ae e1       	ldi	r26, 0x1E	; 30
 130:	b1 e0       	ldi	r27, 0x01	; 1
 132:	01 c0       	rjmp	.+2      	; 0x136 <.do_clear_bss_start>

00000134 <.do_clear_bss_loop>:
 134:	1d 92       	st	X+, r1

00000136 <.do_clear_bss_start>:
 136:	ad 35       	cpi	r26, 0x5D	; 93
 138:	b2 07       	cpc	r27, r18
 13a:	e1 f7       	brne	.-8      	; 0x134 <.do_clear_bss_loop>
 13c:	0e 94 77 02 	call	0x4ee	; 0x4ee <main>
 140:	0c 94 80 04 	jmp	0x900	; 0x900 <_exit>

00000144 <__bad_interrupt>:
 144:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__vector_default>

00000148 <keypad_init>:
    uint8_t i = 0;

    /* Init keypad */
    for (i = 0; i < NUM_BUTTONS; i++)
    {
        keypad[i].input    = false;
 148:	ee e1       	ldi	r30, 0x1E	; 30
 14a:	f1 e0       	ldi	r31, 0x01	; 1
 14c:	10 82       	st	Z, r1
        keypad[i].buttons  = false;
 14e:	13 82       	std	Z+3, r1	; 0x03
        keypad[i].latches  = false;
 150:	12 82       	std	Z+2, r1	; 0x02
        keypad[i].debounce = 0;
 152:	11 82       	std	Z+1, r1	; 0x01
 154:	08 95       	ret

00000156 <keypad_reset_input>:
{
    uint8_t i = 0;

    for (i = 0; i < NUM_BUTTONS; i++)
    {
        keypad[i].input    = false;
 156:	10 92 1e 01 	sts	0x011E, r1
 15a:	08 95       	ret

0000015c <keypad_set_input>:
    }
}

void keypad_set_input(e_key key, bool value)
{
    keypad[key].input = value;
 15c:	24 e0       	ldi	r18, 0x04	; 4
 15e:	82 9f       	mul	r24, r18
 160:	c0 01       	movw	r24, r0
 162:	11 24       	eor	r1, r1
 164:	fc 01       	movw	r30, r24
 166:	e2 5e       	subi	r30, 0xE2	; 226
 168:	fe 4f       	sbci	r31, 0xFE	; 254
 16a:	60 83       	st	Z, r22
 16c:	08 95       	ret

0000016e <keypad_get_input>:
}

bool keypad_get_input(e_key key)
{
    return keypad[key].input;
 16e:	24 e0       	ldi	r18, 0x04	; 4
 170:	82 9f       	mul	r24, r18
 172:	c0 01       	movw	r24, r0
 174:	11 24       	eor	r1, r1
 176:	fc 01       	movw	r30, r24
 178:	e2 5e       	subi	r30, 0xE2	; 226
 17a:	fe 4f       	sbci	r31, 0xFE	; 254
}
 17c:	80 81       	ld	r24, Z
 17e:	08 95       	ret

00000180 <keypad_clicked>:

e_key_event keypad_clicked(e_key key)
{
    return keypad[key].buttons;
 180:	24 e0       	ldi	r18, 0x04	; 4
 182:	82 9f       	mul	r24, r18
 184:	c0 01       	movw	r24, r0
 186:	11 24       	eor	r1, r1
 188:	fc 01       	movw	r30, r24
 18a:	e2 5e       	subi	r30, 0xE2	; 226
 18c:	fe 4f       	sbci	r31, 0xFE	; 254
}
 18e:	83 81       	ldd	r24, Z+3	; 0x03
 190:	08 95       	ret

00000192 <keypad_periodic>:
    uint8_t i = 0;

    for (i = 0; i < NUM_BUTTONS; i++)
    {
        /* the event shall be consumed within a cycle */
        keypad[i].buttons = KEY_NONE;
 192:	10 92 21 01 	sts	0x0121, r1

        /* debounce the raw input */
        if ((flag_debounce == true) && (keypad[i].debounce < KEY_DEBOUNCE_HOLD))
 196:	88 23       	and	r24, r24
 198:	21 f0       	breq	.+8      	; 0x1a2 <keypad_periodic+0x10>
 19a:	80 91 1f 01 	lds	r24, 0x011F
 19e:	8b 34       	cpi	r24, 0x4B	; 75
 1a0:	f0 f0       	brcs	.+60     	; 0x1de <keypad_periodic+0x4c>
        else
        {
            /* flag not available, wait next round */
        }

        if (keypad[i].latches == false && keypad[i].input == true)
 1a2:	80 91 20 01 	lds	r24, 0x0120
 1a6:	88 23       	and	r24, r24
 1a8:	89 f0       	breq	.+34     	; 0x1cc <keypad_periodic+0x3a>
        {
            /* rising edge */
            keypad[i].debounce = 0;
        }
        else if (keypad[i].latches == true && keypad[i].input == true)
 1aa:	80 91 1e 01 	lds	r24, 0x011E
        {

            if (keypad[i].debounce == KEY_DEBOUNCE_HOLD)
 1ae:	90 91 1f 01 	lds	r25, 0x011F
        if (keypad[i].latches == false && keypad[i].input == true)
        {
            /* rising edge */
            keypad[i].debounce = 0;
        }
        else if (keypad[i].latches == true && keypad[i].input == true)
 1b2:	88 23       	and	r24, r24
 1b4:	c1 f0       	breq	.+48     	; 0x1e6 <keypad_periodic+0x54>
        {

            if (keypad[i].debounce == KEY_DEBOUNCE_HOLD)
 1b6:	9b 34       	cpi	r25, 0x4B	; 75
 1b8:	31 f4       	brne	.+12     	; 0x1c6 <keypad_periodic+0x34>
            {
                /* button stayed high for long enough for a hold event */
                keypad[i].buttons = KEY_HOLD;
 1ba:	92 e0       	ldi	r25, 0x02	; 2
 1bc:	90 93 21 01 	sts	0x0121, r25
                /* prevent overflow */
                keypad[i].debounce = KEY_DEBOUNCE_HOLD + 1U;
 1c0:	9c e4       	ldi	r25, 0x4C	; 76
 1c2:	90 93 1f 01 	sts	0x011F, r25
            }

            keypad[i].debounce = 0;
        }

        keypad[i].latches = keypad[i].input;
 1c6:	80 93 20 01 	sts	0x0120, r24
 1ca:	08 95       	ret
        else
        {
            /* flag not available, wait next round */
        }

        if (keypad[i].latches == false && keypad[i].input == true)
 1cc:	80 91 1e 01 	lds	r24, 0x011E
 1d0:	88 23       	and	r24, r24
 1d2:	c9 f3       	breq	.-14     	; 0x1c6 <keypad_periodic+0x34>
            else
            {
                /* either not enough for a click or hold event */
            }

            keypad[i].debounce = 0;
 1d4:	10 92 1f 01 	sts	0x011F, r1
        }

        keypad[i].latches = keypad[i].input;
 1d8:	80 93 20 01 	sts	0x0120, r24
 1dc:	08 95       	ret

        /* debounce the raw input */
        if ((flag_debounce == true) && (keypad[i].debounce < KEY_DEBOUNCE_HOLD))
        {
            /* flag available, count up */
            keypad[i].debounce++;
 1de:	8f 5f       	subi	r24, 0xFF	; 255
 1e0:	80 93 1f 01 	sts	0x011F, r24
 1e4:	de cf       	rjmp	.-68     	; 0x1a2 <keypad_periodic+0x10>
                /* not yet triggered or timeout */
            }
        }
        else if (keypad[i].latches == true && keypad[i].input == false)
        {
            if (keypad[i].debounce >= KEY_DEBOUNCE_CLICK && keypad[i].debounce < KEY_DEBOUNCE_HOLD)
 1e6:	95 50       	subi	r25, 0x05	; 5
 1e8:	96 34       	cpi	r25, 0x46	; 70
 1ea:	a0 f7       	brcc	.-24     	; 0x1d4 <keypad_periodic+0x42>
            {
                /* click event */
                keypad[i].buttons = KEY_CLICK;
 1ec:	91 e0       	ldi	r25, 0x01	; 1
 1ee:	90 93 21 01 	sts	0x0121, r25
 1f2:	f0 cf       	rjmp	.-32     	; 0x1d4 <keypad_periodic+0x42>

000001f4 <i2c_init>:
 * Initialize the i2c subsystem.
 */
void i2c_init(void)
{
    /* Set the birate register, which is computed at compile time */
    TWBR = TWI_TWBR;
 1f4:	8c e0       	ldi	r24, 0x0C	; 12
 1f6:	80 93 b8 00 	sts	0x00B8, r24

    /* Enable the TWI subsystem (initializing the pins) */
    TWCR = (1 << TWEN);
 1fa:	84 e0       	ldi	r24, 0x04	; 4
 1fc:	80 93 bc 00 	sts	0x00BC, r24

    /* Set pull-ups on SDA and SCL pins */
    PORTC |= _BV(PC4) | _BV(PC5);
 200:	88 b1       	in	r24, 0x08	; 8
 202:	80 63       	ori	r24, 0x30	; 48
 204:	88 b9       	out	0x08, r24	; 8

    /* buffer is initially "null" */
    i2c_xfer_buffer = NULL;
 206:	10 92 26 01 	sts	0x0126, r1
 20a:	10 92 25 01 	sts	0x0125, r1
 20e:	08 95       	ret

00000210 <i2c_busy>:
 *
 * @return      0: not busy; else: busy
 */
uint8_t i2c_busy(void)
{
    return (TWCR & (1 << TWIE));
 210:	80 91 bc 00 	lds	r24, 0x00BC
}
 214:	81 70       	andi	r24, 0x01	; 1
 216:	08 95       	ret

00000218 <i2c_get_state_info>:
 * @return      status register
 */
uint8_t i2c_get_state_info(void)
{
    return i2c_state;
}
 218:	80 91 00 01 	lds	r24, 0x0100
 21c:	08 95       	ret

0000021e <i2c_transfer_set_data>:
 *                  happens otherwise. Additionally, it shall remain valid if multiple calls to
 *                  i2c_transfer_start are done in different execution contexts.
 * @param len       length of the data to be transmitted or to be expected
 */
void i2c_transfer_set_data(uint8_t *data, uint8_t len)
{
 21e:	ac 01       	movw	r20, r24
    if (data != NULL)
 220:	89 2b       	or	r24, r25
 222:	d1 f0       	breq	.+52     	; 0x258 <i2c_transfer_set_data+0x3a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 224:	8d e0       	ldi	r24, 0x0D	; 13
 226:	8a 95       	dec	r24
 228:	f1 f7       	brne	.-4      	; 0x226 <i2c_transfer_set_data+0x8>
 22a:	00 00       	nop
static inline void i2c_wait_or_timeout(void)
{
    uint8_t i = 0;
    do
    {
        i++;
 22c:	91 e0       	ldi	r25, 0x01	; 1
        _delay_us(5);
        if (i > I2C_MASTER_TIMEOUT)
        {
            /* Set the error ... */
            i2c_state = TWI_TIMEOUT;
 22e:	31 e0       	ldi	r19, 0x01	; 1
            /* ... and reset the TWI interface */
            TWCR = (1 << TWEN) |       // Enable TWI-interface and release TWI pins
 230:	84 e0       	ldi	r24, 0x04	; 4
 232:	07 c0       	rjmp	.+14     	; 0x242 <i2c_transfer_set_data+0x24>
static inline void i2c_wait_or_timeout(void)
{
    uint8_t i = 0;
    do
    {
        i++;
 234:	9f 5f       	subi	r25, 0xFF	; 255
 236:	2d e0       	ldi	r18, 0x0D	; 13
 238:	2a 95       	dec	r18
 23a:	f1 f7       	brne	.-4      	; 0x238 <i2c_transfer_set_data+0x1a>
 23c:	00 00       	nop
        _delay_us(5);
        if (i > I2C_MASTER_TIMEOUT)
 23e:	99 3c       	cpi	r25, 0xC9	; 201
 240:	60 f4       	brcc	.+24     	; 0x25a <i2c_transfer_set_data+0x3c>
            TWCR = (1 << TWEN) |       // Enable TWI-interface and release TWI pins
                    (0 << TWIE) | (0 << TWINT) |               // Disable Interrupt
                    (0 << TWEA) | (0 << TWSTA) | (0 << TWSTO) | // No Signal requests
                    (0 << TWWC);                                 //
        }
    } while (TWCR & (1 << TWIE));
 242:	20 91 bc 00 	lds	r18, 0x00BC
 246:	20 fd       	sbrc	r18, 0
 248:	f5 cf       	rjmp	.-22     	; 0x234 <i2c_transfer_set_data+0x16>

        /* Wait until TWI is ready for next transmission */
        i2c_wait_or_timeout();

        /* set the data pointer */
        i2c_xfer_buffer = data;
 24a:	50 93 26 01 	sts	0x0126, r21
 24e:	40 93 25 01 	sts	0x0125, r20
        /* set the transmit length */
        i2c_xfer_size = len;
 252:	60 93 24 01 	sts	0x0124, r22
 256:	08 95       	ret
 258:	08 95       	ret
        i++;
        _delay_us(5);
        if (i > I2C_MASTER_TIMEOUT)
        {
            /* Set the error ... */
            i2c_state = TWI_TIMEOUT;
 25a:	30 93 00 01 	sts	0x0100, r19
            /* ... and reset the TWI interface */
            TWCR = (1 << TWEN) |       // Enable TWI-interface and release TWI pins
 25e:	80 93 bc 00 	sts	0x00BC, r24
 262:	ef cf       	rjmp	.-34     	; 0x242 <i2c_transfer_set_data+0x24>

00000264 <i2c_transfer_start>:
 * pointer, its content and/or its length remains constant.
 *
 */
void i2c_transfer_start(void)
{
    if (i2c_xfer_buffer != NULL)
 264:	80 91 25 01 	lds	r24, 0x0125
 268:	90 91 26 01 	lds	r25, 0x0126
 26c:	89 2b       	or	r24, r25
 26e:	e1 f0       	breq	.+56     	; 0x2a8 <i2c_transfer_start+0x44>
 270:	8d e0       	ldi	r24, 0x0D	; 13
 272:	8a 95       	dec	r24
 274:	f1 f7       	brne	.-4      	; 0x272 <i2c_transfer_start+0xe>
 276:	00 00       	nop
static inline void i2c_wait_or_timeout(void)
{
    uint8_t i = 0;
    do
    {
        i++;
 278:	81 e0       	ldi	r24, 0x01	; 1
        _delay_us(5);
        if (i > I2C_MASTER_TIMEOUT)
        {
            /* Set the error ... */
            i2c_state = TWI_TIMEOUT;
 27a:	31 e0       	ldi	r19, 0x01	; 1
            /* ... and reset the TWI interface */
            TWCR = (1 << TWEN) |       // Enable TWI-interface and release TWI pins
 27c:	24 e0       	ldi	r18, 0x04	; 4
 27e:	07 c0       	rjmp	.+14     	; 0x28e <i2c_transfer_start+0x2a>
static inline void i2c_wait_or_timeout(void)
{
    uint8_t i = 0;
    do
    {
        i++;
 280:	8f 5f       	subi	r24, 0xFF	; 255
 282:	9d e0       	ldi	r25, 0x0D	; 13
 284:	9a 95       	dec	r25
 286:	f1 f7       	brne	.-4      	; 0x284 <i2c_transfer_start+0x20>
 288:	00 00       	nop
        _delay_us(5);
        if (i > I2C_MASTER_TIMEOUT)
 28a:	89 3c       	cpi	r24, 0xC9	; 201
 28c:	70 f4       	brcc	.+28     	; 0x2aa <i2c_transfer_start+0x46>
            TWCR = (1 << TWEN) |       // Enable TWI-interface and release TWI pins
                    (0 << TWIE) | (0 << TWINT) |               // Disable Interrupt
                    (0 << TWEA) | (0 << TWSTA) | (0 << TWSTO) | // No Signal requests
                    (0 << TWWC);                                 //
        }
    } while (TWCR & (1 << TWIE));
 28e:	90 91 bc 00 	lds	r25, 0x00BC
 292:	90 fd       	sbrc	r25, 0
 294:	f5 cf       	rjmp	.-22     	; 0x280 <i2c_transfer_start+0x1c>

        /* Wait until TWI is ready for next transmission */
        i2c_wait_or_timeout();

        /* initially, the operation is failed by definition */
        i2c_successful_operation = false;
 296:	10 92 23 01 	sts	0x0123, r1
        /* initially, unknown state */
        i2c_state = TWI_NO_STATE;
 29a:	88 ef       	ldi	r24, 0xF8	; 248
 29c:	80 93 00 01 	sts	0x0100, r24

        TWCR = (1 << TWEN) |                             // TWI Interface enabled.
 2a0:	85 ea       	ldi	r24, 0xA5	; 165
 2a2:	80 93 bc 00 	sts	0x00BC, r24
 2a6:	08 95       	ret
 2a8:	08 95       	ret
        i++;
        _delay_us(5);
        if (i > I2C_MASTER_TIMEOUT)
        {
            /* Set the error ... */
            i2c_state = TWI_TIMEOUT;
 2aa:	30 93 00 01 	sts	0x0100, r19
            /* ... and reset the TWI interface */
            TWCR = (1 << TWEN) |       // Enable TWI-interface and release TWI pins
 2ae:	20 93 bc 00 	sts	0x00BC, r18
 2b2:	ed cf       	rjmp	.-38     	; 0x28e <i2c_transfer_start+0x2a>

000002b4 <i2c_transfer_successful>:
 2b4:	8d e0       	ldi	r24, 0x0D	; 13
 2b6:	8a 95       	dec	r24
 2b8:	f1 f7       	brne	.-4      	; 0x2b6 <i2c_transfer_successful+0x2>
 2ba:	00 00       	nop
static inline void i2c_wait_or_timeout(void)
{
    uint8_t i = 0;
    do
    {
        i++;
 2bc:	81 e0       	ldi	r24, 0x01	; 1
        _delay_us(5);
        if (i > I2C_MASTER_TIMEOUT)
        {
            /* Set the error ... */
            i2c_state = TWI_TIMEOUT;
 2be:	31 e0       	ldi	r19, 0x01	; 1
            /* ... and reset the TWI interface */
            TWCR = (1 << TWEN) |       // Enable TWI-interface and release TWI pins
 2c0:	24 e0       	ldi	r18, 0x04	; 4
 2c2:	07 c0       	rjmp	.+14     	; 0x2d2 <i2c_transfer_successful+0x1e>
static inline void i2c_wait_or_timeout(void)
{
    uint8_t i = 0;
    do
    {
        i++;
 2c4:	8f 5f       	subi	r24, 0xFF	; 255
 2c6:	9d e0       	ldi	r25, 0x0D	; 13
 2c8:	9a 95       	dec	r25
 2ca:	f1 f7       	brne	.-4      	; 0x2c8 <i2c_transfer_successful+0x14>
 2cc:	00 00       	nop
        _delay_us(5);
        if (i > I2C_MASTER_TIMEOUT)
 2ce:	89 3c       	cpi	r24, 0xC9	; 201
 2d0:	98 f4       	brcc	.+38     	; 0x2f8 <i2c_transfer_successful+0x44>
            TWCR = (1 << TWEN) |       // Enable TWI-interface and release TWI pins
                    (0 << TWIE) | (0 << TWINT) |               // Disable Interrupt
                    (0 << TWEA) | (0 << TWSTA) | (0 << TWSTO) | // No Signal requests
                    (0 << TWWC);                                 //
        }
    } while (TWCR & (1 << TWIE));
 2d2:	90 91 bc 00 	lds	r25, 0x00BC
 2d6:	90 fd       	sbrc	r25, 0
 2d8:	f5 cf       	rjmp	.-22     	; 0x2c4 <i2c_transfer_successful+0x10>
uint8_t i2c_transfer_successful(void)
{
    /* Wait until TWI is ready for next transmission */
    i2c_wait_or_timeout();

    if (i2c_successful_operation == false)             error_counter++;
 2da:	80 91 23 01 	lds	r24, 0x0123
 2de:	81 11       	cpse	r24, r1
 2e0:	0a c0       	rjmp	.+20     	; 0x2f6 <i2c_transfer_successful+0x42>
 2e2:	20 91 27 01 	lds	r18, 0x0127
 2e6:	30 91 28 01 	lds	r19, 0x0128
 2ea:	2f 5f       	subi	r18, 0xFF	; 255
 2ec:	3f 4f       	sbci	r19, 0xFF	; 255
 2ee:	30 93 28 01 	sts	0x0128, r19
 2f2:	20 93 27 01 	sts	0x0127, r18

    return i2c_successful_operation;
}
 2f6:	08 95       	ret
        i++;
        _delay_us(5);
        if (i > I2C_MASTER_TIMEOUT)
        {
            /* Set the error ... */
            i2c_state = TWI_TIMEOUT;
 2f8:	30 93 00 01 	sts	0x0100, r19
            /* ... and reset the TWI interface */
            TWCR = (1 << TWEN) |       // Enable TWI-interface and release TWI pins
 2fc:	20 93 bc 00 	sts	0x00BC, r18
 300:	e8 cf       	rjmp	.-48     	; 0x2d2 <i2c_transfer_successful+0x1e>

00000302 <__vector_24>:
/**
 * Interrupt service routine for the TWI interrupt flag.
 * It is called when an operation on the i2c bus has been performed.
 */
ISR(TWI_vect)
{
 302:	1f 92       	push	r1
 304:	0f 92       	push	r0
 306:	0f b6       	in	r0, 0x3f	; 63
 308:	0f 92       	push	r0
 30a:	11 24       	eor	r1, r1
 30c:	2f 93       	push	r18
 30e:	3f 93       	push	r19
 310:	8f 93       	push	r24
 312:	9f 93       	push	r25
 314:	af 93       	push	r26
 316:	bf 93       	push	r27
 318:	ef 93       	push	r30
 31a:	ff 93       	push	r31
    static uint8_t i2c_buf_pos;

    /* mask the register to be compatible also with other prescaler values */
    switch (TWSR & 0xF8U)
 31c:	80 91 b9 00 	lds	r24, 0x00B9
 320:	e8 2f       	mov	r30, r24
 322:	e8 7f       	andi	r30, 0xF8	; 248
 324:	8e 2f       	mov	r24, r30
 326:	90 e0       	ldi	r25, 0x00	; 0
 328:	fc 01       	movw	r30, r24
 32a:	38 97       	sbiw	r30, 0x08	; 8
 32c:	e1 35       	cpi	r30, 0x51	; 81
 32e:	f1 05       	cpc	r31, r1
 330:	a0 f0       	brcs	.+40     	; 0x35a <__vector_24+0x58>
    case TWI_BUS_ERROR:
        /* Bus error due to an illegal START or STOP condition */
    default:

        /* save the state register */
        i2c_state = TWSR;
 332:	80 91 b9 00 	lds	r24, 0x00B9
 336:	80 93 00 01 	sts	0x0100, r24
        /* ... and reset the TWI interface */
        TWCR = (1 << TWEN) |       // Enable TWI-interface and release TWI pins
 33a:	84 e0       	ldi	r24, 0x04	; 4
 33c:	80 93 bc 00 	sts	0x00BC, r24
                (0 << TWIE) | (0 << TWINT) |               // Disable Interrupt
                (0 << TWEA) | (0 << TWSTA) | (0 << TWSTO) | // No Signal requests
                (0 << TWWC);                                 //

    }
}
 340:	ff 91       	pop	r31
 342:	ef 91       	pop	r30
 344:	bf 91       	pop	r27
 346:	af 91       	pop	r26
 348:	9f 91       	pop	r25
 34a:	8f 91       	pop	r24
 34c:	3f 91       	pop	r19
 34e:	2f 91       	pop	r18
 350:	0f 90       	pop	r0
 352:	0f be       	out	0x3f, r0	; 63
 354:	0f 90       	pop	r0
 356:	1f 90       	pop	r1
 358:	18 95       	reti
ISR(TWI_vect)
{
    static uint8_t i2c_buf_pos;

    /* mask the register to be compatible also with other prescaler values */
    switch (TWSR & 0xF8U)
 35a:	ec 5c       	subi	r30, 0xCC	; 204
 35c:	ff 4f       	sbci	r31, 0xFF	; 255
 35e:	0c 94 7a 04 	jmp	0x8f4	; 0x8f4 <__tablejump2__>

    case TWI_MRX_DATA_NACK:

        /* Data byte has been received and NACK transmitted */

        i2c_xfer_buffer[i2c_buf_pos] = TWDR;
 362:	80 91 bb 00 	lds	r24, 0x00BB
 366:	90 91 22 01 	lds	r25, 0x0122
 36a:	e0 91 25 01 	lds	r30, 0x0125
 36e:	f0 91 26 01 	lds	r31, 0x0126
 372:	e9 0f       	add	r30, r25
 374:	f1 1d       	adc	r31, r1
 376:	80 83       	st	Z, r24
        i2c_successful_operation = true;
 378:	81 e0       	ldi	r24, 0x01	; 1
 37a:	80 93 23 01 	sts	0x0123, r24

        TWCR = (1 << TWEN) |                           // TWI Interface enabled
 37e:	84 e9       	ldi	r24, 0x94	; 148
 380:	80 93 bc 00 	sts	0x00BC, r24
                (0 << TWIE) | (1 << TWINT) | // Disable TWI Interrupt and clear the flag
                (0 << TWEA) | (0 << TWSTA) | (1 << TWSTO) | // Initiate a STOP condition.
                (0 << TWWC);                                 //

        break;
 384:	dd cf       	rjmp	.-70     	; 0x340 <__vector_24+0x3e>
        /* START has been transmitted */

    case TWI_REP_START:
        /* Repeated START has been transmitted */

        i2c_buf_pos = 0;
 386:	10 92 22 01 	sts	0x0122, r1
 38a:	80 e0       	ldi	r24, 0x00	; 0
        /* SLA+W has been transmitted and ACK received */

    case TWI_MTX_DATA_ACK:
        /* Data byte has been transmitted and ACK received */

        if (i2c_buf_pos < i2c_xfer_size)
 38c:	90 91 24 01 	lds	r25, 0x0124
 390:	89 17       	cp	r24, r25
 392:	90 f7       	brcc	.-28     	; 0x378 <__vector_24+0x76>
        {
            /* transfer is has not yet been completed */
            TWDR = i2c_xfer_buffer[i2c_buf_pos++];
 394:	e0 91 25 01 	lds	r30, 0x0125
 398:	f0 91 26 01 	lds	r31, 0x0126
 39c:	91 e0       	ldi	r25, 0x01	; 1
 39e:	98 0f       	add	r25, r24
 3a0:	90 93 22 01 	sts	0x0122, r25
 3a4:	e8 0f       	add	r30, r24
 3a6:	f1 1d       	adc	r31, r1
 3a8:	80 81       	ld	r24, Z
 3aa:	80 93 bb 00 	sts	0x00BB, r24

            TWCR = (1 << TWEN) |                       // TWI Interface enabled
 3ae:	85 e8       	ldi	r24, 0x85	; 133
 3b0:	80 93 bc 00 	sts	0x00BC, r24
 3b4:	c5 cf       	rjmp	.-118    	; 0x340 <__vector_24+0x3e>
 3b6:	80 91 22 01 	lds	r24, 0x0122
 3ba:	e8 cf       	rjmp	.-48     	; 0x38c <__vector_24+0x8a>
        break;
    case TWI_ARB_LOST:

        /* Arbitration lost */

        TWCR = (1 << TWEN) |                           // TWI Interface enabled
 3bc:	85 ea       	ldi	r24, 0xA5	; 165
 3be:	80 93 bc 00 	sts	0x00BC, r24
                (1 << TWIE) | (1 << TWINT) | // Enable TWI Interrupt and clear the flag
                (0 << TWEA) | (1 << TWSTA) | (0 << TWSTO) | // Initiate a (RE)START condition.
                (0 << TWWC);                                 //

        break;
 3c2:	be cf       	rjmp	.-132    	; 0x340 <__vector_24+0x3e>
 3c4:	20 91 22 01 	lds	r18, 0x0122

    case TWI_MRX_ADR_ACK:

        /* SLA+R has been transmitted and ACK received */

        if (i2c_buf_pos < (i2c_xfer_size - 1))  // Detect the last byte to NACK it.
 3c8:	30 e0       	ldi	r19, 0x00	; 0
 3ca:	80 91 24 01 	lds	r24, 0x0124
 3ce:	90 e0       	ldi	r25, 0x00	; 0
 3d0:	01 97       	sbiw	r24, 0x01	; 1
 3d2:	28 17       	cp	r18, r24
 3d4:	39 07       	cpc	r19, r25
 3d6:	dc f4       	brge	.+54     	; 0x40e <__vector_24+0x10c>
        {
            TWCR = (1 << TWEN) |                       // TWI Interface enabled
 3d8:	85 ec       	ldi	r24, 0xC5	; 197
 3da:	80 93 bc 00 	sts	0x00BC, r24
 3de:	b0 cf       	rjmp	.-160    	; 0x340 <__vector_24+0x3e>
        break;

    case TWI_MRX_DATA_ACK:
        /* Data byte has been received and ACK transmitted */

        i2c_xfer_buffer[i2c_buf_pos++] = TWDR;
 3e0:	e0 91 25 01 	lds	r30, 0x0125
 3e4:	f0 91 26 01 	lds	r31, 0x0126
 3e8:	80 91 22 01 	lds	r24, 0x0122
 3ec:	21 e0       	ldi	r18, 0x01	; 1
 3ee:	28 0f       	add	r18, r24
 3f0:	20 93 22 01 	sts	0x0122, r18
 3f4:	90 91 bb 00 	lds	r25, 0x00BB
 3f8:	e8 0f       	add	r30, r24
 3fa:	f1 1d       	adc	r31, r1
 3fc:	90 83       	st	Z, r25

    case TWI_MRX_ADR_ACK:

        /* SLA+R has been transmitted and ACK received */

        if (i2c_buf_pos < (i2c_xfer_size - 1))  // Detect the last byte to NACK it.
 3fe:	30 e0       	ldi	r19, 0x00	; 0
 400:	80 91 24 01 	lds	r24, 0x0124
 404:	90 e0       	ldi	r25, 0x00	; 0
 406:	01 97       	sbiw	r24, 0x01	; 1
 408:	28 17       	cp	r18, r24
 40a:	39 07       	cpc	r19, r25
 40c:	2c f3       	brlt	.-54     	; 0x3d8 <__vector_24+0xd6>
                    (1 << TWEA) | (0 << TWSTA) | (0 << TWSTO) | // Send ACK after reception
                    (0 << TWWC);                                 //
        }
        else                    // Send NACK after next reception
        {
            TWCR = (1 << TWEN) |                       // TWI Interface enabled
 40e:	85 e8       	ldi	r24, 0x85	; 133
 410:	80 93 bc 00 	sts	0x00BC, r24
 414:	95 cf       	rjmp	.-214    	; 0x340 <__vector_24+0x3e>

00000416 <i2c_detection.part.0>:
static void i2c_detection(bool enabled)
{
    if (enabled == true)
    {
        /* setup the i2c detection pin (SCL) */
        PCICR  |= _BV(PCIE1);   /* interrupt vector enable */
 416:	e8 e6       	ldi	r30, 0x68	; 104
 418:	f0 e0       	ldi	r31, 0x00	; 0
 41a:	80 81       	ld	r24, Z
 41c:	82 60       	ori	r24, 0x02	; 2
 41e:	80 83       	st	Z, r24
        PCMSK1 |= _BV(PCINT13);  /* mask the only required pin, SCL */
 420:	ec e6       	ldi	r30, 0x6C	; 108
 422:	f0 e0       	ldi	r31, 0x00	; 0
 424:	80 81       	ld	r24, Z
 426:	80 62       	ori	r24, 0x20	; 32
 428:	80 83       	st	Z, r24
 42a:	08 95       	ret

0000042c <status_led>:
    }
}

static void status_led(bool enable)
{
    if (enable == true)
 42c:	81 11       	cpse	r24, r1
 42e:	03 c0       	rjmp	.+6      	; 0x436 <status_led+0xa>
        DDRB |= _BV(PINB5);
        PORTB |= _BV(PINB5);
    }
    else
    {
        DDRB &= ~_BV(PINB5);
 430:	25 98       	cbi	0x04, 5	; 4
        PORTB &= ~_BV(PINB5);
 432:	2d 98       	cbi	0x05, 5	; 5
 434:	08 95       	ret

static void status_led(bool enable)
{
    if (enable == true)
    {
        DDRB |= _BV(PINB5);
 436:	25 9a       	sbi	0x04, 5	; 4
        PORTB |= _BV(PINB5);
 438:	2d 9a       	sbi	0x05, 5	; 5
 43a:	08 95       	ret

0000043c <__vector_14>:
#define SLEEP_AFTER_MS  (30000U)
/** Definition of the minimum i2c inactivity time to wait before starting a transfer on the bus */
#define TX_AFTER_MS     (6U)

ISR(TIMER0_COMPA_vect)
{
 43c:	1f 92       	push	r1
 43e:	0f 92       	push	r0
 440:	0f b6       	in	r0, 0x3f	; 63
 442:	0f 92       	push	r0
 444:	11 24       	eor	r1, r1
 446:	8f 93       	push	r24
 448:	9f 93       	push	r25
 44a:	af 93       	push	r26
 44c:	bf 93       	push	r27
    /* increment the timer variable */
    milliseconds_since_boot += 1;
 44e:	80 91 2b 01 	lds	r24, 0x012B
 452:	90 91 2c 01 	lds	r25, 0x012C
 456:	a0 91 2d 01 	lds	r26, 0x012D
 45a:	b0 91 2e 01 	lds	r27, 0x012E
 45e:	01 96       	adiw	r24, 0x01	; 1
 460:	a1 1d       	adc	r26, r1
 462:	b1 1d       	adc	r27, r1
 464:	80 93 2b 01 	sts	0x012B, r24
 468:	90 93 2c 01 	sts	0x012C, r25
 46c:	a0 93 2d 01 	sts	0x012D, r26
 470:	b0 93 2e 01 	sts	0x012E, r27
}
 474:	bf 91       	pop	r27
 476:	af 91       	pop	r26
 478:	9f 91       	pop	r25
 47a:	8f 91       	pop	r24
 47c:	0f 90       	pop	r0
 47e:	0f be       	out	0x3f, r0	; 63
 480:	0f 90       	pop	r0
 482:	1f 90       	pop	r1
 484:	18 95       	reti

00000486 <__vector_4>:

ISR(PCINT1_vect)
{
 486:	1f 92       	push	r1
 488:	0f 92       	push	r0
 48a:	0f b6       	in	r0, 0x3f	; 63
 48c:	0f 92       	push	r0
 48e:	11 24       	eor	r1, r1
 490:	2f 93       	push	r18
 492:	3f 93       	push	r19
 494:	4f 93       	push	r20
 496:	5f 93       	push	r21
 498:	6f 93       	push	r22
 49a:	7f 93       	push	r23
 49c:	8f 93       	push	r24
 49e:	9f 93       	push	r25
 4a0:	af 93       	push	r26
 4a2:	bf 93       	push	r27
 4a4:	ef 93       	push	r30
 4a6:	ff 93       	push	r31
    /* reset timer if i2c busy */
    TIMER_RESET(SOFT_TIMER_2);
 4a8:	42 e0       	ldi	r20, 0x02	; 2
 4aa:	60 e0       	ldi	r22, 0x00	; 0
 4ac:	70 e0       	ldi	r23, 0x00	; 0
 4ae:	cb 01       	movw	r24, r22
 4b0:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>
    TIMER_RESET(SOFT_TIMER_3);
 4b4:	43 e0       	ldi	r20, 0x03	; 3
 4b6:	60 e0       	ldi	r22, 0x00	; 0
 4b8:	70 e0       	ldi	r23, 0x00	; 0
 4ba:	cb 01       	movw	r24, r22
 4bc:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>
#ifdef DEBUG
    DEBUG_EXEC( { itest++; if (itest > 100) { debug_isr = true; } } );
#endif
}
 4c0:	ff 91       	pop	r31
 4c2:	ef 91       	pop	r30
 4c4:	bf 91       	pop	r27
 4c6:	af 91       	pop	r26
 4c8:	9f 91       	pop	r25
 4ca:	8f 91       	pop	r24
 4cc:	7f 91       	pop	r23
 4ce:	6f 91       	pop	r22
 4d0:	5f 91       	pop	r21
 4d2:	4f 91       	pop	r20
 4d4:	3f 91       	pop	r19
 4d6:	2f 91       	pop	r18
 4d8:	0f 90       	pop	r0
 4da:	0f be       	out	0x3f, r0	; 63
 4dc:	0f 90       	pop	r0
 4de:	1f 90       	pop	r1
 4e0:	18 95       	reti

000004e2 <__vector_default>:

ISR(BADISR_vect)
{
 4e2:	1f 92       	push	r1
 4e4:	0f 92       	push	r0
 4e6:	0f b6       	in	r0, 0x3f	; 63
 4e8:	0f 92       	push	r0
 4ea:	11 24       	eor	r1, r1
    DEBUG_EXEC( { uart_putstring("bad isr!"); } );
    while(1);
 4ec:	ff cf       	rjmp	.-2      	; 0x4ec <__vector_default+0xa>

000004ee <main>:

    DEBUG_EXEC({ uart_putstring("RESUME\r\n"); });
}

int main(void)
{
 4ee:	cf 93       	push	r28
 4f0:	df 93       	push	r29
 4f2:	cd b7       	in	r28, 0x3d	; 61
 4f4:	de b7       	in	r29, 0x3e	; 62
 4f6:	27 97       	sbiw	r28, 0x07	; 7
 4f8:	0f b6       	in	r0, 0x3f	; 63
 4fa:	f8 94       	cli
 4fc:	de bf       	out	0x3e, r29	; 62
 4fe:	0f be       	out	0x3f, r0	; 63
 500:	cd bf       	out	0x3d, r28	; 61
    bool selector_released;

    /* disable all interrupts */
    cli();
 502:	f8 94       	cli

    /* disable all the unnecessary peripherals..
     * ...we are on battery power! */
    power_adc_disable();
 504:	80 91 64 00 	lds	r24, 0x0064
 508:	81 60       	ori	r24, 0x01	; 1
 50a:	80 93 64 00 	sts	0x0064, r24
    power_spi_disable();
 50e:	80 91 64 00 	lds	r24, 0x0064
 512:	84 60       	ori	r24, 0x04	; 4
 514:	80 93 64 00 	sts	0x0064, r24
    power_timer1_disable();
 518:	80 91 64 00 	lds	r24, 0x0064
 51c:	88 60       	ori	r24, 0x08	; 8
 51e:	80 93 64 00 	sts	0x0064, r24
    power_timer2_disable();
 522:	80 91 64 00 	lds	r24, 0x0064
 526:	80 64       	ori	r24, 0x40	; 64
 528:	80 93 64 00 	sts	0x0064, r24

    /* Start 1000Hz system timer */
    OCR0A = F_CPU / 64 / 1000 - 1;
 52c:	8c e7       	ldi	r24, 0x7C	; 124
 52e:	87 bd       	out	0x27, r24	; 39
    TCCR0A = _BV(WGM01);
 530:	82 e0       	ldi	r24, 0x02	; 2
 532:	84 bd       	out	0x24, r24	; 36
    TCCR0B = _BV(CS00) | _BV(CS01);
 534:	93 e0       	ldi	r25, 0x03	; 3
 536:	95 bd       	out	0x25, r25	; 37
    TIMSK0 = _BV(OCIE0A);
 538:	80 93 6e 00 	sts	0x006E, r24

    /* init timer */
    TIMER_RESET(SOFT_TIMER_0);
 53c:	40 e0       	ldi	r20, 0x00	; 0
 53e:	60 e0       	ldi	r22, 0x00	; 0
 540:	70 e0       	ldi	r23, 0x00	; 0
 542:	cb 01       	movw	r24, r22
 544:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>
    TIMER_RESET(SOFT_TIMER_1);
 548:	41 e0       	ldi	r20, 0x01	; 1
 54a:	60 e0       	ldi	r22, 0x00	; 0
 54c:	70 e0       	ldi	r23, 0x00	; 0
 54e:	cb 01       	movw	r24, r22
 550:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>
    TIMER_RESET(SOFT_TIMER_2);
 554:	42 e0       	ldi	r20, 0x02	; 2
 556:	60 e0       	ldi	r22, 0x00	; 0
 558:	70 e0       	ldi	r23, 0x00	; 0
 55a:	cb 01       	movw	r24, r22
 55c:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>
    TIMER_RESET(SOFT_TIMER_3);
 560:	43 e0       	ldi	r20, 0x03	; 3
 562:	60 e0       	ldi	r22, 0x00	; 0
 564:	70 e0       	ldi	r23, 0x00	; 0
 566:	cb 01       	movw	r24, r22
 568:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>

    /* input selector button, input and pull-up */
    DDRD &= ~(_BV(PIND2));
 56c:	52 98       	cbi	0x0a, 2	; 10
    PORTD |= _BV(PIND2);
 56e:	5a 9a       	sbi	0x0b, 2	; 11
 570:	0e 94 0b 02 	call	0x416	; 0x416 <i2c_detection.part.0>
    i2c_detection(true);

    DEBUG_EXEC( { uart_init(); uart_putstring("DEBUG MODE\r\n"); } );

    /* enable all interrupts */
    sei();
 574:	78 94       	sei
//            uart_putstring("receive some interrupts\r\n");
        }
#endif

        /* switch to ground means pressed */
        selector_released = bit_is_clear(PIND, PIND2);
 576:	01 e0       	ldi	r16, 0x01	; 1
            /* go to radio */
            new = SAF7730_INPUT_MUX_RADIO;
            break;
        case SAF7730_INPUT_MUX_RADIO:
            /* go to cd-rom */
            new = SAF7730_INPUT_MUX_CD;
 578:	eb e2       	ldi	r30, 0x2B	; 43
 57a:	9e 2e       	mov	r9, r30
            break;
        case SAF7730_INPUT_MUX_CD:
        default:
            /* go to aux mode */
            new = SAF7730_INPUT_MUX_AUX;
 57c:	f9 e1       	ldi	r31, 0x19	; 25
 57e:	af 2e       	mov	r10, r31
    {
        switch(current)
        {
        case SAF7730_INPUT_MUX_AUX:
            /* go to radio */
            new = SAF7730_INPUT_MUX_RADIO;
 580:	a3 e1       	ldi	r26, 0x13	; 19
 582:	ba 2e       	mov	r11, r26
}

static void saf7730_input_mux_switch(uint8_t source)
{
    uint8_t buf[7];
    buf[0] = (uint8_t)(COMM_SAF7730_ADDR << 1U);
 584:	b8 e3       	ldi	r27, 0x38	; 56
 586:	cb 2e       	mov	r12, r27
    buf[1] = 0x0D;
 588:	1d e0       	ldi	r17, 0x0D	; 13
 58a:	d1 2e       	mov	r13, r17
    buf[2] = 0x00;
    buf[3] = 0x6A;
 58c:	2a e6       	ldi	r18, 0x6A	; 106
 58e:	e2 2e       	mov	r14, r18
    i2c_transfer_start();
    i2c_transfer_successful();

    /* setup the new gain for the given source */
    buf[1] = 0x0D;
    buf[2] = 0x10;
 590:	30 e1       	ldi	r19, 0x10	; 16
 592:	43 2e       	mov	r4, r19
    buf[3] = 0x45;
 594:	45 e4       	ldi	r20, 0x45	; 69
 596:	f4 2e       	mov	r15, r20
        break;
    case SAF7730_INPUT_MUX_AUX:
        /* set some more gain for the AUX input */
        buf[1] = 0x0D;
        buf[2] = 0x10;
        buf[3] = 0x2D;
 598:	5d e2       	ldi	r21, 0x2D	; 45
 59a:	85 2e       	mov	r8, r21
        buf[4] = (uint8_t)((uint16_t)SAF7730_INPUT_GAIN_CD >> 8);
        buf[5] = (uint8_t)(SAF7730_INPUT_GAIN_CD);
        break;
    case SAF7730_INPUT_MUX_AUX:
        buf[4] = (uint8_t)((uint16_t)SAF7730_INPUT_GAIN_AUX >> 8);
        buf[5] = (uint8_t)(SAF7730_INPUT_GAIN_AUX);
 59c:	55 24       	eor	r5, r5
 59e:	5a 94       	dec	r5
        buf[4] = (uint8_t)((uint16_t)SAF7730_INPUT_GAIN_RADIO >> 8);
        buf[5] = (uint8_t)(SAF7730_INPUT_GAIN_RADIO);
        break;
    case SAF7730_INPUT_MUX_CD:
        buf[4] = (uint8_t)((uint16_t)SAF7730_INPUT_GAIN_CD >> 8);
        buf[5] = (uint8_t)(SAF7730_INPUT_GAIN_CD);
 5a0:	6a e5       	ldi	r22, 0x5A	; 90
 5a2:	66 2e       	mov	r6, r22

    switch(source)
    {
    case SAF7730_INPUT_MUX_RADIO:
        buf[4] = (uint8_t)((uint16_t)SAF7730_INPUT_GAIN_RADIO >> 8);
        buf[5] = (uint8_t)(SAF7730_INPUT_GAIN_RADIO);
 5a4:	71 e2       	ldi	r23, 0x21	; 33
 5a6:	77 2e       	mov	r7, r23
 5a8:	09 c0       	rjmp	.+18     	; 0x5bc <main+0xce>
        }

        /* if the i2c bus is not busy for at least 6 milliseconds, select
         * new source when required */
        ON_TIMER_EXPIRED(TX_AFTER_MS,    SOFT_TIMER_2, source_change());
        ON_TIMER_EXPIRED(SLEEP_AFTER_MS, SOFT_TIMER_3, cpu_sleep_periodic());
 5aa:	43 e0       	ldi	r20, 0x03	; 3
 5ac:	60 e3       	ldi	r22, 0x30	; 48
 5ae:	75 e7       	ldi	r23, 0x75	; 117
 5b0:	80 e0       	ldi	r24, 0x00	; 0
 5b2:	90 e0       	ldi	r25, 0x00	; 0
 5b4:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>
 5b8:	81 11       	cpse	r24, r1
 5ba:	85 c0       	rjmp	.+266    	; 0x6c6 <main+0x1d8>
//            uart_putstring("receive some interrupts\r\n");
        }
#endif

        /* switch to ground means pressed */
        selector_released = bit_is_clear(PIND, PIND2);
 5bc:	69 b1       	in	r22, 0x09	; 9
 5be:	62 fb       	bst	r22, 2
 5c0:	66 27       	eor	r22, r22
 5c2:	60 f9       	bld	r22, 0
 5c4:	60 27       	eor	r22, r16
        /* pass it to the keypad logic */
        keypad_set_input(BUTTON_SELECT, selector_released);
 5c6:	80 e0       	ldi	r24, 0x00	; 0
 5c8:	0e 94 ae 00 	call	0x15c	; 0x15c <keypad_set_input>

        /* this logic shall always be run periodically */
        keypad_periodic(timeout(10, SOFT_TIMER_1));
 5cc:	41 e0       	ldi	r20, 0x01	; 1
 5ce:	6a e0       	ldi	r22, 0x0A	; 10
 5d0:	70 e0       	ldi	r23, 0x00	; 0
 5d2:	80 e0       	ldi	r24, 0x00	; 0
 5d4:	90 e0       	ldi	r25, 0x00	; 0
 5d6:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>
 5da:	0e 94 c9 00 	call	0x192	; 0x192 <keypad_periodic>

        if (keypad_clicked(BUTTON_SELECT) == KEY_CLICK)
 5de:	80 e0       	ldi	r24, 0x00	; 0
 5e0:	0e 94 c0 00 	call	0x180	; 0x180 <keypad_clicked>
 5e4:	81 30       	cpi	r24, 0x01	; 1
 5e6:	09 f4       	brne	.+2      	; 0x5ea <main+0xfc>
 5e8:	5f c0       	rjmp	.+190    	; 0x6a8 <main+0x1ba>
            source_select_next();
        }

        /* if the i2c bus is not busy for at least 6 milliseconds, select
         * new source when required */
        ON_TIMER_EXPIRED(TX_AFTER_MS,    SOFT_TIMER_2, source_change());
 5ea:	42 e0       	ldi	r20, 0x02	; 2
 5ec:	66 e0       	ldi	r22, 0x06	; 6
 5ee:	70 e0       	ldi	r23, 0x00	; 0
 5f0:	80 e0       	ldi	r24, 0x00	; 0
 5f2:	90 e0       	ldi	r25, 0x00	; 0
 5f4:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>
 5f8:	88 23       	and	r24, r24
 5fa:	b9 f2       	breq	.-82     	; 0x5aa <main+0xbc>
    TWCR = 0;
}

static void source_change(void)
{
    if (new != current)
 5fc:	90 91 29 01 	lds	r25, 0x0129
 600:	80 91 2a 01 	lds	r24, 0x012A
 604:	98 17       	cp	r25, r24
 606:	89 f2       	breq	.-94     	; 0x5aa <main+0xbc>
        PCMSK1 |= _BV(PCINT13);  /* mask the only required pin, SCL */
    }
    else
    {
        /* setup the i2c detection pin (SCL) */
        PCICR  &= ~_BV(PCIE1);   /* interrupt vector enable */
 608:	80 91 68 00 	lds	r24, 0x0068
 60c:	8d 7f       	andi	r24, 0xFD	; 253
 60e:	80 93 68 00 	sts	0x0068, r24
        PCMSK1 &= ~_BV(PCINT13);  /* mask the only required pin, SCL */
 612:	80 91 6c 00 	lds	r24, 0x006C
 616:	8f 7d       	andi	r24, 0xDF	; 223
 618:	80 93 6c 00 	sts	0x006C, r24
}

static void i2c_init_override(void)
{
    /* two-wire init, also enables pull-ups */
    i2c_init();
 61c:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <i2c_init>
    /* disable pull-ups for SDA and SCL: the bus is already provided with them */
    PORTC &= ~(_BV(PC4) | _BV(PC5));
 620:	88 b1       	in	r24, 0x08	; 8
 622:	8f 7c       	andi	r24, 0xCF	; 207
 624:	88 b9       	out	0x08, r24	; 8
                    } );
        i2c_detection(false);
        /* initialize the two-wire */
        i2c_init_override();
        /* perform the command */
        saf7730_input_mux_switch(new);
 626:	10 91 29 01 	lds	r17, 0x0129
}

static void saf7730_input_mux_switch(uint8_t source)
{
    uint8_t buf[7];
    buf[0] = (uint8_t)(COMM_SAF7730_ADDR << 1U);
 62a:	c9 82       	std	Y+1, r12	; 0x01
    buf[1] = 0x0D;
 62c:	da 82       	std	Y+2, r13	; 0x02
    buf[2] = 0x00;
 62e:	1b 82       	std	Y+3, r1	; 0x03
    buf[3] = 0x6A;
 630:	ec 82       	std	Y+4, r14	; 0x04
    buf[4] = 0x00;
 632:	1d 82       	std	Y+5, r1	; 0x05
    buf[5] = 0x00;
 634:	1e 82       	std	Y+6, r1	; 0x06
    buf[6] = source;
 636:	1f 83       	std	Y+7, r17	; 0x07

    /* start the i2c transfer and wait for it */
    i2c_transfer_set_data(buf, sizeof(buf));
 638:	67 e0       	ldi	r22, 0x07	; 7
 63a:	ce 01       	movw	r24, r28
 63c:	01 96       	adiw	r24, 0x01	; 1
 63e:	0e 94 0f 01 	call	0x21e	; 0x21e <i2c_transfer_set_data>
    i2c_transfer_start();
 642:	0e 94 32 01 	call	0x264	; 0x264 <i2c_transfer_start>
    i2c_transfer_successful();
 646:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <i2c_transfer_successful>

    /* setup the new gain for the given source */
    buf[1] = 0x0D;
 64a:	da 82       	std	Y+2, r13	; 0x02
    buf[2] = 0x10;
 64c:	4b 82       	std	Y+3, r4	; 0x03
    buf[3] = 0x45;
 64e:	fc 82       	std	Y+4, r15	; 0x04

    switch(source)
 650:	19 31       	cpi	r17, 0x19	; 25
 652:	09 f4       	brne	.+2      	; 0x656 <main+0x168>
 654:	8e c0       	rjmp	.+284    	; 0x772 <main+0x284>
 656:	1b 32       	cpi	r17, 0x2B	; 43
 658:	09 f4       	brne	.+2      	; 0x65c <main+0x16e>
 65a:	87 c0       	rjmp	.+270    	; 0x76a <main+0x27c>
 65c:	13 31       	cpi	r17, 0x13	; 19
 65e:	09 f4       	brne	.+2      	; 0x662 <main+0x174>
 660:	80 c0       	rjmp	.+256    	; 0x762 <main+0x274>
    default:
        break;
    }

    /* start the i2c transfer and wait for it */
    i2c_transfer_set_data(buf, 6U);
 662:	66 e0       	ldi	r22, 0x06	; 6
 664:	ce 01       	movw	r24, r28
 666:	01 96       	adiw	r24, 0x01	; 1
 668:	0e 94 0f 01 	call	0x21e	; 0x21e <i2c_transfer_set_data>
    i2c_transfer_start();
 66c:	0e 94 32 01 	call	0x264	; 0x264 <i2c_transfer_start>
    i2c_transfer_successful();
 670:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <i2c_transfer_successful>

    switch(source)
 674:	19 31       	cpi	r17, 0x19	; 25
 676:	79 f4       	brne	.+30     	; 0x696 <main+0x1a8>
    case SAF7730_INPUT_MUX_CD:
        /* do not set any overridden gain value here */
        break;
    case SAF7730_INPUT_MUX_AUX:
        /* set some more gain for the AUX input */
        buf[1] = 0x0D;
 678:	da 82       	std	Y+2, r13	; 0x02
        buf[2] = 0x10;
 67a:	4b 82       	std	Y+3, r4	; 0x03
        buf[3] = 0x2D;
 67c:	8c 82       	std	Y+4, r8	; 0x04
        buf[4] = 0x07;
 67e:	87 e0       	ldi	r24, 0x07	; 7
 680:	8d 83       	std	Y+5, r24	; 0x05
        buf[5] = 0x00;
 682:	1e 82       	std	Y+6, r1	; 0x06
        /* start the i2c transfer and wait for it */
        i2c_transfer_set_data(buf, 6U);
 684:	66 e0       	ldi	r22, 0x06	; 6
 686:	ce 01       	movw	r24, r28
 688:	01 96       	adiw	r24, 0x01	; 1
 68a:	0e 94 0f 01 	call	0x21e	; 0x21e <i2c_transfer_set_data>
        i2c_transfer_start();
 68e:	0e 94 32 01 	call	0x264	; 0x264 <i2c_transfer_start>
        i2c_transfer_successful();
 692:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <i2c_transfer_successful>
}

static void i2c_deinit_override(void)
{
    /* Disable the TWI subsystem */
    TWCR = 0;
 696:	10 92 bc 00 	sts	0x00BC, r1
 69a:	0e 94 0b 02 	call	0x416	; 0x416 <i2c_detection.part.0>
        /* perform the command */
        saf7730_input_mux_switch(new);
        /* deinitialize the two-wire interface */
        i2c_deinit_override();
        i2c_detection(true);
        current = new;
 69e:	80 91 29 01 	lds	r24, 0x0129
 6a2:	80 93 2a 01 	sts	0x012A, r24
 6a6:	81 cf       	rjmp	.-254    	; 0x5aa <main+0xbc>

}

static void source_select_next(void)
{
    if (current == new)
 6a8:	80 91 2a 01 	lds	r24, 0x012A
 6ac:	90 91 29 01 	lds	r25, 0x0129
 6b0:	89 13       	cpse	r24, r25
 6b2:	9b cf       	rjmp	.-202    	; 0x5ea <main+0xfc>
    {
        switch(current)
 6b4:	83 31       	cpi	r24, 0x13	; 19
 6b6:	09 f4       	brne	.+2      	; 0x6ba <main+0x1cc>
 6b8:	6c c0       	rjmp	.+216    	; 0x792 <main+0x2a4>
 6ba:	89 31       	cpi	r24, 0x19	; 25
 6bc:	09 f0       	breq	.+2      	; 0x6c0 <main+0x1d2>
 6be:	66 c0       	rjmp	.+204    	; 0x78c <main+0x29e>
        {
        case SAF7730_INPUT_MUX_AUX:
            /* go to radio */
            new = SAF7730_INPUT_MUX_RADIO;
 6c0:	b0 92 29 01 	sts	0x0129, r11
 6c4:	92 cf       	rjmp	.-220    	; 0x5ea <main+0xfc>
 6c6:	10 e0       	ldi	r17, 0x00	; 0
 6c8:	99 e1       	ldi	r25, 0x19	; 25
 6ca:	e9 2e       	mov	r14, r25
 6cc:	f1 2c       	mov	r15, r1
    DEBUG_EXEC({ uart_putstring("SLEEP\r\n"); _delay_ms(50); });

    /* notify sleep by led */
    for (int i = 0; i < 25; i++)
    {
        status_led((bool)(i & 0x1));
 6ce:	81 2f       	mov	r24, r17
 6d0:	81 70       	andi	r24, 0x01	; 1
 6d2:	0e 94 16 02 	call	0x42c	; 0x42c <status_led>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 6d6:	8f e4       	ldi	r24, 0x4F	; 79
 6d8:	93 ec       	ldi	r25, 0xC3	; 195
 6da:	01 97       	sbiw	r24, 0x01	; 1
 6dc:	f1 f7       	brne	.-4      	; 0x6da <main+0x1ec>
 6de:	00 c0       	rjmp	.+0      	; 0x6e0 <main+0x1f2>
 6e0:	00 00       	nop
 6e2:	91 e0       	ldi	r25, 0x01	; 1
 6e4:	e9 1a       	sub	r14, r25
 6e6:	f1 08       	sbc	r15, r1
 6e8:	1f 5f       	subi	r17, 0xFF	; 255
 6ea:	11 70       	andi	r17, 0x01	; 1
static void cpu_sleep_periodic(void)
{
    DEBUG_EXEC({ uart_putstring("SLEEP\r\n"); _delay_ms(50); });

    /* notify sleep by led */
    for (int i = 0; i < 25; i++)
 6ec:	e1 14       	cp	r14, r1
 6ee:	f1 04       	cpc	r15, r1
 6f0:	71 f7       	brne	.-36     	; 0x6ce <main+0x1e0>
     * Brown-out Reset
     * 2-wire Serial Interface address match
     * External level interrupt on INT
     * Pin change interrupt
     * */
    set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 6f2:	83 b7       	in	r24, 0x33	; 51
 6f4:	81 7f       	andi	r24, 0xF1	; 241
 6f6:	84 60       	ori	r24, 0x04	; 4
 6f8:	83 bf       	out	0x33, r24	; 51

    cli();
 6fa:	f8 94       	cli

    sleep_enable();
 6fc:	83 b7       	in	r24, 0x33	; 51
 6fe:	81 60       	ori	r24, 0x01	; 1
 700:	83 bf       	out	0x33, r24	; 51
    sei();
 702:	78 94       	sei
    sleep_cpu();
 704:	88 95       	sleep
    sleep_disable();
 706:	83 b7       	in	r24, 0x33	; 51
 708:	8e 7f       	andi	r24, 0xFE	; 254
 70a:	83 bf       	out	0x33, r24	; 51

    /* reset timers */
    TIMER_RESET(SOFT_TIMER_2);
 70c:	42 e0       	ldi	r20, 0x02	; 2
 70e:	60 e0       	ldi	r22, 0x00	; 0
 710:	70 e0       	ldi	r23, 0x00	; 0
 712:	cb 01       	movw	r24, r22
 714:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>
    TIMER_RESET(SOFT_TIMER_3);
 718:	43 e0       	ldi	r20, 0x03	; 3
 71a:	60 e0       	ldi	r22, 0x00	; 0
 71c:	70 e0       	ldi	r23, 0x00	; 0
 71e:	cb 01       	movw	r24, r22
 720:	0e 94 cc 03 	call	0x798	; 0x798 <timeout>
    /* prevent changing source if it was to
     * be applied before sleeping */
    new = current;
 724:	80 91 2a 01 	lds	r24, 0x012A
 728:	80 93 29 01 	sts	0x0129, r24
 72c:	10 e0       	ldi	r17, 0x00	; 0
 72e:	8f e0       	ldi	r24, 0x0F	; 15
 730:	e8 2e       	mov	r14, r24
 732:	f1 2c       	mov	r15, r1

    /* notify sleep by led */
    for (int i = 0; i < 15; i++)
    {
        status_led((bool)(i & 0x1));
 734:	81 2f       	mov	r24, r17
 736:	81 70       	andi	r24, 0x01	; 1
 738:	0e 94 16 02 	call	0x42c	; 0x42c <status_led>
 73c:	2f eb       	ldi	r18, 0xBF	; 191
 73e:	84 ed       	ldi	r24, 0xD4	; 212
 740:	91 e0       	ldi	r25, 0x01	; 1
 742:	21 50       	subi	r18, 0x01	; 1
 744:	80 40       	sbci	r24, 0x00	; 0
 746:	90 40       	sbci	r25, 0x00	; 0
 748:	e1 f7       	brne	.-8      	; 0x742 <main+0x254>
 74a:	00 c0       	rjmp	.+0      	; 0x74c <main+0x25e>
 74c:	00 00       	nop
 74e:	21 e0       	ldi	r18, 0x01	; 1
 750:	e2 1a       	sub	r14, r18
 752:	f1 08       	sbc	r15, r1
 754:	1f 5f       	subi	r17, 0xFF	; 255
 756:	11 70       	andi	r17, 0x01	; 1
    /* prevent changing source if it was to
     * be applied before sleeping */
    new = current;

    /* notify sleep by led */
    for (int i = 0; i < 15; i++)
 758:	e1 14       	cp	r14, r1
 75a:	f1 04       	cpc	r15, r1
 75c:	59 f7       	brne	.-42     	; 0x734 <main+0x246>
    {
        status_led((bool)(i & 0x1));
        _delay_ms(75);
    }

    sei();
 75e:	78 94       	sei
 760:	15 cf       	rjmp	.-470    	; 0x58c <main+0x9e>
    buf[3] = 0x45;

    switch(source)
    {
    case SAF7730_INPUT_MUX_RADIO:
        buf[4] = (uint8_t)((uint16_t)SAF7730_INPUT_GAIN_RADIO >> 8);
 762:	87 e0       	ldi	r24, 0x07	; 7
 764:	8d 83       	std	Y+5, r24	; 0x05
        buf[5] = (uint8_t)(SAF7730_INPUT_GAIN_RADIO);
 766:	7e 82       	std	Y+6, r7	; 0x06
 768:	8d cf       	rjmp	.-230    	; 0x684 <main+0x196>
        break;
    case SAF7730_INPUT_MUX_CD:
        buf[4] = (uint8_t)((uint16_t)SAF7730_INPUT_GAIN_CD >> 8);
 76a:	86 e0       	ldi	r24, 0x06	; 6
 76c:	8d 83       	std	Y+5, r24	; 0x05
        buf[5] = (uint8_t)(SAF7730_INPUT_GAIN_CD);
 76e:	6e 82       	std	Y+6, r6	; 0x06
 770:	89 cf       	rjmp	.-238    	; 0x684 <main+0x196>
        break;
    case SAF7730_INPUT_MUX_AUX:
        buf[4] = (uint8_t)((uint16_t)SAF7730_INPUT_GAIN_AUX >> 8);
 772:	87 e0       	ldi	r24, 0x07	; 7
 774:	8d 83       	std	Y+5, r24	; 0x05
        buf[5] = (uint8_t)(SAF7730_INPUT_GAIN_AUX);
 776:	5e 82       	std	Y+6, r5	; 0x06
    default:
        break;
    }

    /* start the i2c transfer and wait for it */
    i2c_transfer_set_data(buf, 6U);
 778:	66 e0       	ldi	r22, 0x06	; 6
 77a:	ce 01       	movw	r24, r28
 77c:	01 96       	adiw	r24, 0x01	; 1
 77e:	0e 94 0f 01 	call	0x21e	; 0x21e <i2c_transfer_set_data>
    i2c_transfer_start();
 782:	0e 94 32 01 	call	0x264	; 0x264 <i2c_transfer_start>
    i2c_transfer_successful();
 786:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <i2c_transfer_successful>
 78a:	76 cf       	rjmp	.-276    	; 0x678 <main+0x18a>
            new = SAF7730_INPUT_MUX_CD;
            break;
        case SAF7730_INPUT_MUX_CD:
        default:
            /* go to aux mode */
            new = SAF7730_INPUT_MUX_AUX;
 78c:	a0 92 29 01 	sts	0x0129, r10
 790:	2c cf       	rjmp	.-424    	; 0x5ea <main+0xfc>
            /* go to radio */
            new = SAF7730_INPUT_MUX_RADIO;
            break;
        case SAF7730_INPUT_MUX_RADIO:
            /* go to cd-rom */
            new = SAF7730_INPUT_MUX_CD;
 792:	90 92 29 01 	sts	0x0129, r9
 796:	29 cf       	rjmp	.-430    	; 0x5ea <main+0xfc>

00000798 <timeout>:
 * @param timer_id      the soft-timer identifier
 * @return  true : timer expired
 *          false: timer not yet expired or in reset state
 */
bool timeout(uint32_t cycles, e_timer_id timer_id)
{
 798:	8f 92       	push	r8
 79a:	9f 92       	push	r9
 79c:	af 92       	push	r10
 79e:	bf 92       	push	r11
 7a0:	cf 92       	push	r12
 7a2:	df 92       	push	r13
 7a4:	ef 92       	push	r14
 7a6:	ff 92       	push	r15
 7a8:	6b 01       	movw	r12, r22
 7aa:	7c 01       	movw	r14, r24

    bool retval;
    uint32_t tmr;

    TIMER_ATOMIC(
 7ac:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 7ae:	f8 94       	cli
 7b0:	80 91 2b 01 	lds	r24, 0x012B
 7b4:	90 91 2c 01 	lds	r25, 0x012C
 7b8:	a0 91 2d 01 	lds	r26, 0x012D
 7bc:	b0 91 2e 01 	lds	r27, 0x012E
 7c0:	e4 2f       	mov	r30, r20
 7c2:	f0 e0       	ldi	r31, 0x00	; 0
 7c4:	ee 0f       	add	r30, r30
 7c6:	ff 1f       	adc	r31, r31
 7c8:	ee 0f       	add	r30, r30
 7ca:	ff 1f       	adc	r31, r31
 7cc:	ef 5c       	subi	r30, 0xCF	; 207
 7ce:	fe 4f       	sbci	r31, 0xFE	; 254
 7d0:	c1 14       	cp	r12, r1
 7d2:	d1 04       	cpc	r13, r1
 7d4:	e1 04       	cpc	r14, r1
 7d6:	f1 04       	cpc	r15, r1
 7d8:	79 f4       	brne	.+30     	; 0x7f8 <timeout+0x60>
 7da:	80 83       	st	Z, r24
 7dc:	91 83       	std	Z+1, r25	; 0x01
 7de:	a2 83       	std	Z+2, r26	; 0x02
 7e0:	b3 83       	std	Z+3, r27	; 0x03
 7e2:	80 e0       	ldi	r24, 0x00	; 0
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 7e4:	2f bf       	out	0x3f, r18	; 63
        }
    };
    );

    return retval;
}
 7e6:	ff 90       	pop	r15
 7e8:	ef 90       	pop	r14
 7ea:	df 90       	pop	r13
 7ec:	cf 90       	pop	r12
 7ee:	bf 90       	pop	r11
 7f0:	af 90       	pop	r10
 7f2:	9f 90       	pop	r9
 7f4:	8f 90       	pop	r8
 7f6:	08 95       	ret
{

    bool retval;
    uint32_t tmr;

    TIMER_ATOMIC(
 7f8:	40 81       	ld	r20, Z
 7fa:	51 81       	ldd	r21, Z+1	; 0x01
 7fc:	62 81       	ldd	r22, Z+2	; 0x02
 7fe:	73 81       	ldd	r23, Z+3	; 0x03
 800:	4c 01       	movw	r8, r24
 802:	5d 01       	movw	r10, r26
 804:	84 1a       	sub	r8, r20
 806:	95 0a       	sbc	r9, r21
 808:	a6 0a       	sbc	r10, r22
 80a:	b7 0a       	sbc	r11, r23
 80c:	8c 14       	cp	r8, r12
 80e:	9d 04       	cpc	r9, r13
 810:	ae 04       	cpc	r10, r14
 812:	bf 04       	cpc	r11, r15
 814:	30 f0       	brcs	.+12     	; 0x822 <timeout+0x8a>
 816:	80 83       	st	Z, r24
 818:	91 83       	std	Z+1, r25	; 0x01
 81a:	a2 83       	std	Z+2, r26	; 0x02
 81c:	b3 83       	std	Z+3, r27	; 0x03
 81e:	81 e0       	ldi	r24, 0x01	; 1
 820:	e1 cf       	rjmp	.-62     	; 0x7e4 <timeout+0x4c>
 822:	80 e0       	ldi	r24, 0x00	; 0
 824:	df cf       	rjmp	.-66     	; 0x7e4 <timeout+0x4c>

00000826 <uart_putchar>:
    uart_cb = cb;
}

void uart_putchar(char c, FILE *stream)
{
    loop_until_bit_is_set(UCSRA, UDRE);
 826:	90 91 c0 00 	lds	r25, 0x00C0
 82a:	95 ff       	sbrs	r25, 5
 82c:	fc cf       	rjmp	.-8      	; 0x826 <uart_putchar>
    UDR = c;
 82e:	80 93 c6 00 	sts	0x00C6, r24
 832:	08 95       	ret

00000834 <uart_getchar>:
    }
}

char uart_getchar(FILE *stream)
{
    loop_until_bit_is_set(UCSRA, RXC);
 834:	80 91 c0 00 	lds	r24, 0x00C0
 838:	87 ff       	sbrs	r24, 7
 83a:	fc cf       	rjmp	.-8      	; 0x834 <uart_getchar>
    return UDR;
 83c:	80 91 c6 00 	lds	r24, 0x00C6
}
 840:	08 95       	ret

00000842 <uart_init>:

void uart_init(void)
{

    /* Enable UART power */
    power_usart0_enable();
 842:	e4 e6       	ldi	r30, 0x64	; 100
 844:	f0 e0       	ldi	r31, 0x00	; 0
 846:	80 81       	ld	r24, Z
 848:	8d 7f       	andi	r24, 0xFD	; 253
 84a:	80 83       	st	Z, r24

    /* configure ports double mode */
    #if USE_2X
        UCSRA |= _BV(U2X0);
    #else
        UCSRA &= ~(_BV(U2X0));
 84c:	e0 ec       	ldi	r30, 0xC0	; 192
 84e:	f0 e0       	ldi	r31, 0x00	; 0
 850:	80 81       	ld	r24, Z
 852:	8d 7f       	andi	r24, 0xFD	; 253
 854:	80 83       	st	Z, r24
    #endif

    /* configure the ports speed */
    UBRR0H = UBRRH_VALUE;
 856:	10 92 c5 00 	sts	0x00C5, r1
    UBRR0L = UBRRL_VALUE;
 85a:	83 e3       	ldi	r24, 0x33	; 51
 85c:	80 93 c4 00 	sts	0x00C4, r24

    // asynchronous, 8N1 mode
//    UCSR0C |= 0x06;
    UCSRC = _BV(UCSZ1) | _BV(UCSZ0);
 860:	86 e0       	ldi	r24, 0x06	; 6
 862:	80 93 c2 00 	sts	0x00C2, r24


    /* Enable RX and TX */
    UCSR0B = _BV(RXEN) | _BV(TXEN);
 866:	e1 ec       	ldi	r30, 0xC1	; 193
 868:	f0 e0       	ldi	r31, 0x00	; 0
 86a:	88 e1       	ldi	r24, 0x18	; 24
 86c:	80 83       	st	Z, r24

    /* RX interrupt */
    UCSR0B |= (1<<RXCIE0);
 86e:	80 81       	ld	r24, Z
 870:	80 68       	ori	r24, 0x80	; 128
 872:	80 83       	st	Z, r24
 874:	08 95       	ret

00000876 <__vector_18>:
//    UBRRL = UBRRL_VALUE;

}

ISR(USART_RX_vect)
{
 876:	1f 92       	push	r1
 878:	0f 92       	push	r0
 87a:	0f b6       	in	r0, 0x3f	; 63
 87c:	0f 92       	push	r0
 87e:	11 24       	eor	r1, r1
 880:	2f 93       	push	r18
 882:	3f 93       	push	r19
 884:	4f 93       	push	r20
 886:	5f 93       	push	r21
 888:	6f 93       	push	r22
 88a:	7f 93       	push	r23
 88c:	8f 93       	push	r24
 88e:	9f 93       	push	r25
 890:	af 93       	push	r26
 892:	bf 93       	push	r27
 894:	ef 93       	push	r30
 896:	ff 93       	push	r31
    /* byte received ! */
    if (uart_cb != NULL)
 898:	e0 91 2f 01 	lds	r30, 0x012F
 89c:	f0 91 30 01 	lds	r31, 0x0130
 8a0:	30 97       	sbiw	r30, 0x00	; 0
 8a2:	19 f0       	breq	.+6      	; 0x8aa <__vector_18+0x34>
    {
        uart_cb(UDR);
 8a4:	80 91 c6 00 	lds	r24, 0x00C6
 8a8:	09 95       	icall
    }
}
 8aa:	ff 91       	pop	r31
 8ac:	ef 91       	pop	r30
 8ae:	bf 91       	pop	r27
 8b0:	af 91       	pop	r26
 8b2:	9f 91       	pop	r25
 8b4:	8f 91       	pop	r24
 8b6:	7f 91       	pop	r23
 8b8:	6f 91       	pop	r22
 8ba:	5f 91       	pop	r21
 8bc:	4f 91       	pop	r20
 8be:	3f 91       	pop	r19
 8c0:	2f 91       	pop	r18
 8c2:	0f 90       	pop	r0
 8c4:	0f be       	out	0x3f, r0	; 63
 8c6:	0f 90       	pop	r0
 8c8:	1f 90       	pop	r1
 8ca:	18 95       	reti

000008cc <uart_callback>:

void uart_callback(t_uart_cb cb)
{
    uart_cb = cb;
 8cc:	90 93 30 01 	sts	0x0130, r25
 8d0:	80 93 2f 01 	sts	0x012F, r24
 8d4:	08 95       	ret

000008d6 <uart_putstring>:
    UDR = c;
}

void uart_putstring(char *str)
{
    while (*str != 0)
 8d6:	fc 01       	movw	r30, r24
 8d8:	20 81       	ld	r18, Z
 8da:	22 23       	and	r18, r18
 8dc:	51 f0       	breq	.+20     	; 0x8f2 <uart_putstring+0x1c>
 8de:	31 96       	adiw	r30, 0x01	; 1
    uart_cb = cb;
}

void uart_putchar(char c, FILE *stream)
{
    loop_until_bit_is_set(UCSRA, UDRE);
 8e0:	90 91 c0 00 	lds	r25, 0x00C0
 8e4:	95 ff       	sbrs	r25, 5
 8e6:	fc cf       	rjmp	.-8      	; 0x8e0 <uart_putstring+0xa>
    UDR = c;
 8e8:	20 93 c6 00 	sts	0x00C6, r18
}

void uart_putstring(char *str)
{
    while (*str != 0)
 8ec:	21 91       	ld	r18, Z+
 8ee:	21 11       	cpse	r18, r1
 8f0:	f7 cf       	rjmp	.-18     	; 0x8e0 <uart_putstring+0xa>
 8f2:	08 95       	ret

000008f4 <__tablejump2__>:
 8f4:	ee 0f       	add	r30, r30
 8f6:	ff 1f       	adc	r31, r31
 8f8:	05 90       	lpm	r0, Z+
 8fa:	f4 91       	lpm	r31, Z
 8fc:	e0 2d       	mov	r30, r0
 8fe:	09 94       	ijmp

00000900 <_exit>:
 900:	f8 94       	cli

00000902 <__stop_program>:
 902:	ff cf       	rjmp	.-2      	; 0x902 <__stop_program>
